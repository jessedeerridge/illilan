<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>„ÉÜ„É≥„Éó„É¨</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn[disabled]{opacity:.45; cursor:not-allowed;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('illtop.jpg'); }
  main.joined{ background-image:url('illmain.jpg'); }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'‚úï';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;width:260px;height:260px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;border:none;
  }
  .player-circle::before{content:'';}
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    user-select:none;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  .player-tag.other-turn{
    width:56px;
    height:56px;
    padding:0;
    border-radius:50%;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    text-align:center;
    white-space:normal;
    line-height:1.05;
  }
  .player-tag.other-turn .turn-name{
    font-weight:800;
    font-size:12px;
    line-height:1.05;
  }
  .player-tag.other-turn .turn-dots{
    margin-top:3px;
    font-size:12px;
    line-height:1.0;
  }
  .player-tag.other-turn .turn-dash{
    margin-top:2px;
    font-size:12px;
    line-height:1.0;
  }

  .vote-wrap{
    position:absolute;
    left:50%;
    top:100%;
    transform:translate(-50%,8px);
    display:flex;
    gap:10px;
    z-index:6;
    pointer-events:auto;
  }
  .vote-btn{
    width:70px;height:70px;
    border-radius:50%;
    border:none;
    padding:0;
    cursor:pointer;
    background:#fff;
    background-size:cover;
    background-position:center;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    touch-action:manipulation;
  }
  .vote-btn.good{ background-image:url('iru.png'); }
  .vote-btn.bad{  background-image:url('iran.png'); }

  .vote-wrap.pulsing .vote-btn{
    animation: votePulse .95s ease-in-out infinite;
    transform-origin:center center;
  }
  @keyframes votePulse{
    0%{ transform:scale(0.92); }
    50%{ transform:scale(1.08); }
    100%{ transform:scale(0.92); }
  }

  .vote-wrap.locked .vote-btn{ animation:none !important; }
  .vote-btn.faded{ opacity:.28; }
  .vote-btn.selected{ opacity:1; }

  .vote-indicator{
    position:absolute;
    width:50px;height:50px;
    border-radius:50%;
    border:none;
    background:#fff;
    background-size:cover;
    background-position:center;
    box-shadow:0 12px 28px rgba(0,0,0,.22);
    pointer-events:none;
    z-index:90;
    transform:translate(-50%,-50%);
  }
  .vote-indicator.good{ background-image:url('iru.png'); }
  .vote-indicator.bad{  background-image:url('iran.png'); }

  .player-tag .mini-hand{
    position:absolute;
    left:50%;
    bottom:100%;
    transform: translate(-50%,30px) scale(1.5);
    transform-origin: bottom center;
    width:96px;height:54px;
    pointer-events:none;
  }

  .card-front{
    background:#d11;
    color:#fff;
    border:1px solid rgba(0,0,0,.18);
  }

  .player-tag .mini-card{
    position:absolute;left:50%;top:0;
    width:28px;height:40px;
    border-radius:8px;
    font-size:21px;font-weight:900;
    display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    background:#d11;color:#fff;border:1px solid rgba(0,0,0,.18);
    overflow:hidden;
  }

  .player-tag .mini-hand .hand-finger{
    position:absolute;
    right:15px;
    bottom:-6px;
    width:26px;
    height:auto;
    pointer-events:none;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,.18));
    z-index:100;
  }

  .mini-zone{
    position:absolute;
    left:50%; top:50%;
    min-width:34px;
    height:52px;
    border:none;
    border-radius:10px;
    background:transparent;
    box-shadow:none;
    transform-origin:center center;
    display:flex;
    flex-direction:row;
    align-items:flex-end;
    justify-content:center;
    gap:8px;
    padding:4px;
    pointer-events:auto;
    z-index:60;
  }
  .mini-zone::after{ content:none; }

  body.dragging-my-card .mini-zone{ background:transparent; }
  body.dragging-my-card .mini-zone.hint{ background:rgba(56, 189, 248, .12); }
  body.dragging-my-card .mini-zone.hint.target{ background:rgba(56, 189, 248, .22); }

  .zone-card{
    width:28px;height:40px;border-radius:8px;
    background:#d11;color:#fff;
    border:1px solid rgba(0,0,0,.18);
    display:flex;align-items:center;justify-content:center;
    font-size:21px;font-weight:900;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    user-select:none;
    pointer-events:none;
    position:absolute;
    left:0;
    bottom:0;
    overflow:hidden;
  }

  .zone-stack{
    position:relative;
    width:28px;
    flex:0 0 auto;
  }

  /* ===== Bomb BG (11..14) ===== */
  .card-label-wrap{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  .card-label-wrap .bomb-bg{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    font-size:24px;
    line-height:1;
    opacity:.84;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,.18));
    z-index:0;
  }
  .card-label-wrap .num-fg{
    position:relative;
    z-index:1;
  }
  .mini-card .card-label-wrap .bomb-bg,
  .zone-card .card-label-wrap .bomb-bg{
    font-size:22px;
    opacity:.84;
  }
  .fly-card.front .card-label-wrap .bomb-bg{
    font-size:30px;
    opacity:.84;
  }
  .fly-card.small.front .card-label-wrap .bomb-bg{
    font-size:24px;
    opacity:.84;
  }

  .my-hand-wrapper{margin-top:96px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{
    display:flex;justify-content:center;gap:8px;margin-top:6px;
    min-height:110px;
    position:relative;
  }

  .my-hand-finger{
    position:absolute;
    right:-38px;
    bottom:-14px;
    width:56px;
    height:auto;
    pointer-events:none;
    z-index:12000;
    filter: drop-shadow(0 10px 18px rgba(0,0,0,.22));
  }

  body.dragging-my-card .my-hand-finger{ display:none !important; }
  body.dragging-my-card .hand-finger{ display:none !important; }

  .my-card{
    width:60px;height:90px;border-radius:10px;
    border:1px solid #ddd;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    user-select:none;
    touch-action:none;
    transform-origin:center center;
    animation:none;
    cursor:default;
    opacity:1;
    position:relative;
    overflow:hidden;

    background:#fff;
    background-image:url('illura.jpg');
    background-size:cover;
    background-position:center;
    color:transparent;
  }

  .my-card .card-label{
    position:absolute;inset:0;
    display:flex;align-items:center;justify-content:center;
    font-size:24px;font-weight:800;
    opacity:0;
    color:#fff;
    text-shadow:0 2px 10px rgba(0,0,0,.25);
    pointer-events:none;
  }

  .my-card.faceup{
    background-image:none;
    background:#d11;
    color:#fff;
    border-color:rgba(0,0,0,.18);
  }
  .my-card.faceup .card-label{ opacity:1; }

  .my-card.pulsing{
    animation: cardPulse 1.0s ease-in-out infinite;
    cursor:grab;
  }
  .my-card.pulsing:active{ cursor:grabbing; }

  @keyframes cardPulse{
    0%{ transform:scale(0.94); }
    50%{ transform:scale(1.06); }
    100%{ transform:scale(0.94); }
  }

  .my-card.dragging{
    animation:none !important;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    opacity:.98;
    cursor:grabbing;
  }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}

  .help-grid{
    display:grid;
    grid-template-columns:repeat(4, minmax(0, 1fr));
    gap:10px;
  }
  .help-card{
    position:relative;
    width:60px;
    height:90px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.14);
    background:#d11;
    color:#fff;
    box-shadow:0 10px 22px rgba(0,0,0,.14);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    user-select:none;
  }
  .help-card .help-label{
    font-size:28px;
    font-weight:900;
    text-shadow:0 2px 10px rgba(0,0,0,.22);
    display:flex;
    align-items:center;
    justify-content:center;
    width:100%;
    height:100%;
    pointer-events:none;
  }
  .help-count-tag{
    position:absolute;
    top:-10px;
    right:-10px;
    padding:4px 8px;
    border-radius:999px;
    background:rgba(0,0,0,.72);
    color:#fff;
    font-size:12px;
    font-weight:900;
    line-height:1;
    box-shadow:0 8px 18px rgba(0,0,0,.18);
    pointer-events:none;
  }
  .help-card{ overflow:visible; }

  @media (max-width: 420px){
    .help-grid{ grid-template-columns:repeat(2, minmax(0, 1fr)); }
    .help-card .help-label{ font-size:26px; }
  }

  .deck-area{
    position:absolute;left:50%;top:50%;
    transform:translate(-50%,-50%);
    width:36px;height:51px;
    z-index:50;
    display:flex;align-items:center;justify-content:center;
    pointer-events:none;
  }
  .deck-stack{
    position:relative;
    width:33px;height:48px;
  }
  .deck-card{
    position:absolute;left:0;top:0;
    width:33px;height:48px;border-radius:8px;
    border:1px solid rgba(0,0,0,.25);

    background:#fff;
    background-image:url('illura.jpg');
    background-size:cover;
    background-position:center;

    box-shadow:0 10px 22px rgba(0,0,0,.20);
  }

  .deck-count{ display:none !important; }

  .fly-card{
    position:fixed;
    width:60px;height:90px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.20);
    box-shadow:0 18px 40px rgba(0,0,0,.22);
    display:flex;align-items:center;justify-content:center;
    font-size:24px;font-weight:800;
    z-index:20000;
    pointer-events:none;
    transform:translate(-50%,-50%);
    will-change:transform, opacity;
    overflow:hidden;
  }
  .fly-card.small{
    width:33px;height:48px;
    border-radius:8px;
    font-size:21px;
    font-weight:900;
  }
  .fly-card.front{
    background:#d11;color:#fff;
  }
  .fly-card.back{
    background:#fff;
    background-image:url('illura.jpg');
    background-size:cover;
    background-position:center;
    color:transparent;
  }

  /* bomb marker under name tag */
  .name-bomb{
    position:absolute;
    left:50%;
    top:100%;
    transform:translate(-50%, 4px);
    font-size:18px;
    line-height:1;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,.18));
    pointer-events:none;
  }

  /* faded mini area after bomb */
  .mini-zone.bombed .zone-card{
    opacity:.35;
    filter:saturate(.85);
  }

  /* bomb scatter animation overlay */
  .bomb-burst{
    position:fixed;
    left:0;top:0;
    z-index:50000;
    pointer-events:none;
  }
  .bomb-piece{
    position:absolute;
    left:0;top:0;
    transform:translate(-50%,-50%);
    will-change:transform, opacity;
    filter: drop-shadow(0 10px 18px rgba(0,0,0,.22));
  }
</style>
</head>
<body>

<header>
  <h1>„ÉÜ„É≥„Éó„É¨</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="ÂêçÂâçÔºà4ÊñáÂ≠ó‰ª•ÂÜÖÔºâ" maxlength="4" />
    <input id="roomCode" placeholder="„É´„Éº„É†„Ç≥„Éº„ÉâÔºàÊú™ÂÖ•Âäõ„ÅßËá™ÂãïÁîüÊàêÔºâ" maxlength="12" />
    <button class="btn primary" id="btnJoin">ÂÖ•ÂÆ§</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>„É≠„Éì„Éº</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>„Åì„Åì„Å´„ÉÜ„Éº„Éñ„É´„ÇÑÊÉÖÂ†±„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>

    <div id="playerCircle" class="player-circle"></div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">Ëá™ÂàÜ„ÅÆ„Ç´„Éº„Éâ</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">„Éõ„Çπ„Éà„Åå‰∫∫Êï∞„ÇíÈÅ∏Êäû‰∏≠</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>Â∏≠„ÇíÈÅ∏Êäû</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">Ë¶≥Êà¶</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">Êó¢Â≠ò„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÇíËøΩ„ÅÑÂá∫„Åó„Å¶„ÄÅÁùÄÂ∏≠„Åó„Åæ„Åô„ÅãÔºü</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">„ÅÑ„ÅÑ„Åà</button>
      <button class="btn primary" id="btnKickYes">„ÅØ„ÅÑ</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="Ë®≠ÂÆö">‚öô</button>
<button id="helpBtn" class="help-btn" title="„Ç´„Éº„Éâ„É™„Çπ„Éà">Ôºü</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="„Ç´„Éº„Éâ„É™„Çπ„Éà">
    <div class="help-pop-header">
      <div class="help-pop-title">„Ç´„Éº„Éâ„É™„Çπ„Éà</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">√ó</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">„Éõ„Çπ„ÉàË®≠ÂÆö</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">√ó</button>
  </div>
  <div class="start-pop-main">
    „Äå„Çπ„Çø„Éº„Éà„ÄçÔºö„Åæ„ÅöÂÖ®Âì°„ÅÆ„Éü„Éã„Ç´„Éº„Éâ„Ç®„É™„Ç¢„Å´<strong>1Êûö„Åö„Å§</strong>ÈÖç„Çã ‚Üí „É©„É≥„ÉÄ„É†„Å´ÂÖàÊâã„ÇíÊ±∫„ÇÅ„ÄÅ„Åù„ÅÆ‰∫∫„Å†„Åë<strong>ÊâãÊú≠„Çí1Êûö</strong>Âèó„ÅëÂèñ„Çä„Åæ„Åô„ÄÇ<br>
    ÂÖàÊâã„ÅØÊâãÊú≠„ÇíÁΩÆ„ÅÑ„Åü„ÇâÂç≥Ê¨°„ÅÆ‰∫∫„Å∏„ÄÇ‰ª•Èôç„ÅØ„ÄåËá™Âãï„Éâ„É≠„Éº ‚Üí ÁΩÆ„Åè„Äç„ÅßÈÄ≤Ë°å„Åó„Åæ„Åô„ÄÇ
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">„É™„Çª„ÉÉ„Éà</button>
    <button id="btnGameStart" class="btn primary">„Çπ„Çø„Éº„Éà</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* =========================
   ‚òÖ „Éá„ÉÉ„Ç≠ÊßãÊàê
   ========================= */
function makeInitialDeck(){
  const deck = [];
  for (let n=2; n<=8; n++){
    for (let i=0; i<n; i++) deck.push(n);
  }
  deck.push(11,12,13);
  return deck;
}

/* =========================
   scoring & bomb flow config
   ========================= */
const BOMB_POINT_VALUES = new Set([11,12,13]);
const POINT_THRESHOLD = 2;
const BOMB_ANIM_MS = 950;
const BOMB_FADE_MS = 180;
function now(){ return Date.now(); }
function isFrozenNow(){
  const u = state.room?.freezeUntil;
  return (typeof u === 'number' && u > now());
}
function isBombed(pid){
  return !!state.room?.bombed?.[pid];
}

/* =========================
   ‚úÖ ÊäïÁ•®„ÅÆÈõÜË®àÂØæË±°ÔºàÈùûËÑ±ËêΩËÄÖ„ÅÆ„ÅøÔºâ
   ========================= */
function getActivePlayers(){
  const players = Array.isArray(latestPlayers) ? latestPlayers : [];
  return players.filter(p => !isBombed(p.id));
}
function getActivePlayerIdsSet(){
  return new Set(getActivePlayers().map(p => p.id));
}

/* =========================
   ‚úÖ points
   ========================= */
function computePointsFromPlacedList(placedList){
  const counts = new Map();
  for (const pc of placedList){
    const v = pc?.value;
    if (typeof v !== 'number') continue;
    counts.set(v, (counts.get(v) || 0) + 1);
  }

  let points = 0;

  for (const v of [11,12,13]){
    points += (counts.get(v) || 0);
  }

  for (const [v, c] of counts.entries()){
    points += Math.floor(c / 2);
  }

  return points;
}

/* =========================
   bomb scatter animation
   ========================= */
function getNameBombAnchorRect(pid){
  const tag = playerCircle.querySelector(`.player-tag[data-player-id="${pid}"]`);
  if (!tag) return null;
  const r = tag.getBoundingClientRect();
  const x = r.left + r.width/2;
  const y = r.bottom + 10;
  return { x, y };
}

function playBombScatterAt({ x, y, big=false }){
  const wrap = document.createElement('div');
  wrap.className = 'bomb-burst';
  document.body.appendChild(wrap);

  const baseSize = big ? 30 : 24;
  const n = 8;
  const duration = BOMB_ANIM_MS;

  const pieces = [];
  for (let i=0;i<n;i++){
    const p = document.createElement('div');
    p.className = 'bomb-piece';
    p.textContent = 'üí•';
    p.style.left = `${x}px`;
    p.style.top  = `${y}px`;
    p.style.fontSize = `${baseSize}px`;
    p.style.opacity = '1';
    wrap.appendChild(p);
    pieces.push(p);
  }

  const angles = pieces.map((_, i) => (i / n) * Math.PI * 2);
  const distBase = big ? 86 : 72;

  const start = performance.now();
  return new Promise(resolve => {
    function step(tNow){
      const t = Math.max(0, Math.min(1, (tNow - start) / duration));
      const e = 1 - Math.pow(1 - t, 3);

      pieces.forEach((p, i) => {
        const a = angles[i] + (i % 2 ? 0.18 : -0.14);
        const dist = distBase * (0.25 + 0.9 * e);
        const dx = Math.cos(a) * dist;
        const dy = Math.sin(a) * dist - (18 * e);
        const s  = (big ? 1.05 : 1.0) * (1 - 0.25*t);
        p.style.transform = `translate(-50%,-50%) translate(${dx}px, ${dy}px) scale(${s}) rotate(${(i*18)*e}deg)`;
        p.style.opacity = String(1 - 0.95*t);
      });

      if (t < 1){
        requestAnimationFrame(step);
      } else {
        wrap.remove();
        resolve();
      }
    }
    requestAnimationFrame(step);
  });
}

async function playBombForPlayer(pid){
  const anchor = getNameBombAnchorRect(pid);
  if (!anchor) {
    await new Promise(r => setTimeout(r, BOMB_ANIM_MS));
    return;
  }
  const big = (pid === state.userId);
  await playBombScatterAt({ x: anchor.x, y: anchor.y, big });
}

/* bombEvents subscription */
let bombEventsInitialized = false;
let lastBombEventKeys = new Set();
const animatedBombEvents = new Set();

function subscribeBombEvents(){
  const bRef = ref(db, `rooms/${state.roomCode}/bombEvents`);
  onValue(bRef, async snap => {
    const next = snap.val() || {};
    const newKeys = new Set();
    const newItems = [];

    for (const [k, ev] of Object.entries(next)){
      if (!ev || !ev.playerId || typeof ev.at !== 'number') continue;
      newKeys.add(k);
      if (bombEventsInitialized && !lastBombEventKeys.has(k)){
        newItems.push({ key:k, ev });
      }
    }

    if (bombEventsInitialized && newItems.length){
      for (const { key, ev } of newItems){
        if (animatedBombEvents.has(key)) continue;
        animatedBombEvents.add(key);
        await playBombForPlayer(ev.playerId);
      }
    }

    bombEventsInitialized = true;
    lastBombEventKeys = newKeys;
  });
}

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  placedCards: {},

  deck: makeInitialDeck(),

  turn: { playerId: null, phase: 'draw' },
  turnOrder: [],

  autoDrawRunning: false,

  myVote: null,
  votes: {}
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

/* =========================
   „Ç¢„Éã„É°Ë£úÂä©
   ========================= */
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function getCenterRect(el){
  const r = el.getBoundingClientRect();
  return { x: r.left + r.width/2, y: r.top + r.height/2, w:r.width, h:r.height };
}
function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

/* 11,12,13,14 Ë°®Á§∫ */
function isBombCard(v){
  return v === 11 || v === 12 || v === 13 || v === 14;
}
function makeCardLabelNode(v){
  const wrap = document.createElement('span');
  wrap.className = 'card-label-wrap';

  const num = document.createElement('span');
  num.className = 'num-fg';
  num.textContent = String(v);

  if (isBombCard(v)){
    const bomb = document.createElement('span');
    bomb.className = 'bomb-bg';
    bomb.textContent = 'üí£';
    wrap.appendChild(bomb);
  }
  wrap.appendChild(num);
  return wrap;
}
function setCardLabelInto(el, v){
  el.textContent = '';
  el.appendChild(makeCardLabelNode(v));
}

function animateFlyCard({ fromEl, toEl, label, small=false, duration=360, bump=0.05, back=false }){
  if (!fromEl || !toEl) return Promise.resolve();

  const from = getCenterRect(fromEl);
  const to   = getCenterRect(toEl);

  const fly = document.createElement('div');
  fly.className = 'fly-card' + (small ? ' small' : '') + (back ? ' back' : ' front');

  if (back){
    fly.textContent = '';
  } else {
    setCardLabelInto(fly, (label != null ? Number(label) : label));
  }

  document.body.appendChild(fly);

  fly.style.left = `${from.x}px`;
  fly.style.top  = `${from.y}px`;

  const startScale = small ? 1.0 : 0.98;
  const endScale   = small ? 1.05 : 1.02;

  const start = performance.now();
  return new Promise(resolve => {
    function step(now){
      const t = clamp((now - start)/duration, 0, 1);
      const e = easeOutCubic(t);

      const x = from.x + (to.x - from.x) * e;
      const y = from.y + (to.y - from.y) * e;

      const s = startScale + (endScale - startScale) * e;

      const extra = (t > 0.7) ? (Math.sin((t-0.7)/0.3 * Math.PI) * bump) : 0;
      const scale = s + extra;

      fly.style.left = `${x}px`;
      fly.style.top  = `${y}px`;
      fly.style.transform = `translate(-50%,-50%) scale(${scale})`;
      fly.style.opacity = String(1 - (t>0.92 ? (t-0.92)/0.08 : 0));

      if (t < 1){
        requestAnimationFrame(step);
      } else {
        fly.remove();
        resolve();
      }
    }
    requestAnimationFrame(step);
  });
}

function getDeckTopEl(){
  const stack = playerCircle.querySelector('.deck-stack');
  if (!stack) return null;
  const cards = stack.querySelectorAll('.deck-card');
  return cards?.[cards.length-1] || stack;
}
function getMyHandTargetEl(){
  const last = myHandEl.querySelector('.my-card:last-child');
  return last || myHandEl;
}
function getDrawTargetElForPlayer(pid){
  if (pid === state.userId){
    return getMyHandTargetEl();
  }
  const tag = playerCircle.querySelector(`.player-tag[data-player-id="${pid}"]`);
  return tag || playerCircle;
}

/* placedCardsÂ∑ÆÂàÜÊ§úÂá∫ */
let placedInitialized = false;
let lastPlacedKeys = new Set();

/* drawEventsÂ∑ÆÂàÜÊ§úÂá∫ */
let drawEventsInitialized = false;
let lastDrawEventKeys = new Set();
const animatedDrawEvents = new Set();

/* „Éâ„É©„ÉÉ„Ç∞Áä∂ÊÖã */
let drag = { active:false, cardEl:null, value:null, sourceIndex:null, offsetX:0, offsetY:0, startX:0, startY:0 };
let miniZonesByPlayerId = new Map();

/* =========================
   ‚úÖ ÊäïÁ•® ‚Üí „Éâ„É©„ÉÉ„Ç∞Ëß£Á¶ÅÂà§ÂÆöÔºÜ„Éâ„É≠„ÉÉ„ÉóÂÖàÂà∂Âæ°
   ÔºàÈùûËÑ±ËêΩËÄÖ„ÅÆ„Åø„ÅßÂà§ÂÆöÔºâ
   ========================= */
function getVoteChoice(pid){
  const v = state.votes?.[pid]?.choice;
  return (v === 'good' || v === 'bad') ? v : null;
}

function allActivePlayersExceptMeVoted(){
  const active = getActivePlayers();
  const others = active.filter(p => p.id !== state.userId).map(p => p.id);

  // ‚úÖ ÈùûËÑ±ËêΩ„ÅÆ‰ªñ„Éó„É¨„Ç§„É§„Éº„Åå0‰∫∫„Å™„ÇâÊäïÁ•®ÂæÖ„Å°„ÅØ‰∏çË¶ÅÔºàË©∞„ÅøÈò≤Ê≠¢Ôºâ
  if (!others.length) return true;

  return others.every(pid => !!getVoteChoice(pid));
}

function getEligibleDropPlayerIds(){
  const active = getActivePlayers();
  if (!active.length) return new Set();

  if (!allActivePlayersExceptMeVoted()) return new Set();

  const activeIds = new Set(active.map(p => p.id));
  const meActive = activeIds.has(state.userId);

  const others = active.filter(p => p.id !== state.userId).map(p => p.id);
  const goodOthers = others.filter(pid => getVoteChoice(pid) === 'good');

  // ‚úÖ ËÑ±ËêΩËÄÖ„ÅØÁµ∂ÂØæÂê´„ÇÅ„Å™„ÅÑ
  const eligible = new Set();
  if (meActive) eligible.add(state.userId);

  if (goodOthers.length > 0){
    for (const pid of goodOthers){
      if (activeIds.has(pid)) eligible.add(pid);
    }
    return eligible;
  }

  // ‚úÖ good„Åå0„Å™„Çâ„ÄåÈùûËÑ±ËêΩËÄÖÂÖ®Âì°„Äç
  for (const p of active) eligible.add(p.id);
  return eligible;
}

function isMyTurn(){
  return state.turn?.playerId && state.turn.playerId === state.userId;
}

function canDragMyHandNow(){
  if (!allActivePlayersExceptMeVoted()) return false;
  if (!isMyTurn()) return false;
  if (state.turn.phase !== 'place') return false;
  if (isFrozenNow()) return false;
  if (isBombed(state.userId)) return false;

  const eligible = getEligibleDropPlayerIds();
  return eligible.size > 0;
}

function applyHintZonesDuringDrag(){
  const eligible = getEligibleDropPlayerIds();
  for (const [pid, z] of miniZonesByPlayerId.entries()){
    z.classList.toggle('hint', eligible.has(pid));
  }
}
function clearHintZones(){
  for (const z of miniZonesByPlayerId.values()){
    z.classList.remove('hint','target');
  }
}

/* ÊäïÁ•®ÈÅ∏Êäû */
async function chooseMyVote(choice){
  if (isMyTurn()) return;
  if (!state.roomCode) return;
  // ‚úÖ ËÑ±ËêΩËÄÖ„ÅØÊäïÁ•®„Åó„Å™„ÅÑÔºàUI„ÇÇÂá∫„Åï„Å™„ÅÑ„Åå‰øùÈô∫Ôºâ
  if (isBombed(state.userId)) return;

  state.myVote = choice;
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);

  await set(ref(db, `rooms/${state.roomCode}/votes/${state.userId}`), {
    choice,
    at: Date.now()
  });
}

/* ÊäïÁ•®Ë≥ºË™≠ */
function subscribeVotes(){
  const votesRef = ref(db, `rooms/${state.roomCode}/votes`);
  onValue(votesRef, snap => {
    state.votes = snap.val() || {};

    const me = state.votes?.[state.userId];
    state.myVote = (me && (me.choice === 'good' || me.choice === 'bad')) ? me.choice : null;

    renderHands();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}

/* „Çø„Éº„É≥ÂàáÊõø„ÅÆ„Åü„Å≥„Å´ votes „Çí„É™„Çª„ÉÉ„ÉàÔºà„Éõ„Çπ„Éà„ÅåÂÆüË°åÔºâ */
let prevTurnPlayerIdForVoteReset = null;
async function resetVotesIfTurnSwitched(nextTurnPlayerId){
  if (!state.roomCode) return;

  const switched = (prevTurnPlayerIdForVoteReset !== null && prevTurnPlayerIdForVoteReset !== nextTurnPlayerId);
  prevTurnPlayerIdForVoteReset = nextTurnPlayerId;

  if (!switched) return;

  if (state.isHost){
    await remove(ref(db, `rooms/${state.roomCode}/votes`));
  }
}

/* Help */
function getDeckCounts(){
  const deck = makeInitialDeck();
  const map = new Map();
  for (const v of deck){
    map.set(v, (map.get(v) || 0) + 1);
  }
  const values = Array.from(map.keys()).sort((a,b)=>a-b);
  return values.map(v => ({ value:v, count: map.get(v) || 0 }));
}

function renderHelpList(){
  helpBody.innerHTML = '';

  const grid = document.createElement('div');
  grid.className = 'help-grid';

  const items = getDeckCounts();
  items.forEach(({value, count}) => {
    const card = document.createElement('div');
    card.className = 'help-card';

    const tag = document.createElement('div');
    tag.className = 'help-count-tag';
    tag.textContent = `√ó${count}`;

    const label = document.createElement('div');
    label.className = 'help-label';
    setCardLabelInto(label, value);

    card.appendChild(tag);
    card.appendChild(label);
    grid.appendChild(card);
  });

  helpBody.appendChild(grid);
}

function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? 'Ôºà„Éõ„Çπ„ÉàÔºâ' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
    renderTurnUI();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
    renderTurnUI();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}

function subscribeDrawEvents(){
  const drawRef = ref(db, `rooms/${state.roomCode}/drawEvents`);
  onValue(drawRef, async snap => {
    const next = snap.val() || {};

    const newKeys = new Set();
    const newItems = [];

    for (const [k, ev] of Object.entries(next)){
      if (!ev || typeof ev.value !== 'number' || !ev.playerId) continue;
      newKeys.add(k);
      if (drawEventsInitialized && !lastDrawEventKeys.has(k)){
        newItems.push({ key:k, ev });
      }
    }

    if (drawEventsInitialized && newItems.length){
      for (const it of newItems){
        const { key, ev } = it;
        if (animatedDrawEvents.has(key)) continue;
        animatedDrawEvents.add(key);

        await new Promise(r => requestAnimationFrame(r));

        const fromEl = getDeckTopEl() || playerCircle.querySelector('.deck-area') || playerCircle;
        const toEl = getDrawTargetElForPlayer(ev.playerId);

        if (fromEl && toEl){
          await animateFlyCard({
            fromEl,
            toEl,
            label: ev.value,
            small:false,
            duration: 420,
            back: true
          });
        }

        if (ev.playerId === state.userId){
          const myId = state.userId;
          const handData = state.hands[myId];
          const cards = (handData && Array.isArray(handData.cards)) ? handData.cards.slice() : [];
          cards.push(ev.value);

          await set(ref(db, `rooms/${state.roomCode}/hands/${myId}`), { cards });
          await remove(ref(db, `rooms/${state.roomCode}/drawEvents/${key}`));
        }
      }
    }

    drawEventsInitialized = true;
    lastDrawEventKeys = newKeys;
  });
}

function subscribePlacedCards(){
  const placedRef = ref(db, `rooms/${state.roomCode}/placedCards`);
  onValue(placedRef, async snap => {
    const next = snap.val() || {};

    const newKeys = new Set();
    const newItems = [];

    for (const [targetPid, node] of Object.entries(next)){
      if (node && typeof node === 'object'){
        for (const [k, pc] of Object.entries(node)){
          if (!pc || typeof pc.value !== 'number') continue;
          newKeys.add(`${targetPid}:${k}`);
          if (placedInitialized && !lastPlacedKeys.has(`${targetPid}:${k}`)){
            newItems.push({ targetPid, key:k, pc });
          }
        }
      }
    }

    state.placedCards = next;
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);

    if (placedInitialized && newItems.length){
      for (const it of newItems){
        const pc = it.pc;
        if (pc.placedBy === 'system') continue;
        if (pc.placedBy === state.userId) continue;

        const fromPid = pc.placedBy;
        const targetPid = it.targetPid;

        const fromTag = playerCircle.querySelector(`.player-tag[data-player-id="${fromPid}"]`);
        const toZone  = miniZonesByPlayerId.get(targetPid);

        let fromEl = null;
        if (fromTag){
          const miniHand = fromTag.querySelector('.mini-hand');
          const lastMini = miniHand?.querySelector('.mini-card:last-child');
          fromEl = lastMini || miniHand || fromTag;
        }
        if (fromEl && toZone){
          await animateFlyCard({
            fromEl,
            toEl: toZone,
            label: pc.value,
            small:true,
            duration: 320,
            back: false
          });
        }
      }
    }

    placedInitialized = true;
    lastPlacedKeys = newKeys;
  });
}

function subscribeDeck(){
  const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
  onValue(deckRef, snap => {
    const d = snap.val();
    state.deck = (Array.isArray(d) ? d : []);
    renderDeck();
    renderTurnUI();
  });
}

function subscribeTurn(){
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
  onValue(turnRef, async snap => {
    const t = snap.val() || { playerId:null, phase:'draw' };
    const nextPlayerId = t.playerId || null;

    state.turn = { playerId: nextPlayerId, phase: t.phase || 'draw', drawLockBy: t.drawLockBy || null };

    await resetVotesIfTurnSwitched(nextPlayerId);

    if (isMyTurn()){
      state.myVote = null;
    }

    renderTurnUI();
    renderHands();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);

    if (isMyTurn() && state.turn.phase === 'draw'){
      if (!isFrozenNow() && !isBombed(state.userId)){
        await autoDrawOneCard();
      }
    }
  });
}

function subscribeTurnOrder(){
  const orderRef = ref(db, `rooms/${state.roomCode}/turnOrder`);
  onValue(orderRef, snap => {
    const arr = snap.val();
    state.turnOrder = Array.isArray(arr) ? arr : [];
    renderTurnUI();
  });
}

function renderMyHand(){
  myHandEl.innerHTML = '';

  const myId = state.userId;
  const handData = state.hands[myId];
  const cardsArr = (handData && Array.isArray(handData.cards)) ? handData.cards : [];
  if (!cardsArr) return;

  const dragEnabled = canDragMyHandNow();

  cardsArr.forEach((v, idx) => {
    const card = document.createElement('div');
    card.className = 'my-card' + (dragEnabled ? ' pulsing' : '');
    card.dataset.value = String(v);

    const label = document.createElement('span');
    label.className = 'card-label';
    setCardLabelInto(label, v);
    card.appendChild(label);

    card.addEventListener('pointerdown', (e) => {
      if (!state.roomCode) return;
      if (!canDragMyHandNow()) return;
      startDrag(e, card, v, idx);
    });

    myHandEl.appendChild(card);
  });

  if (isMyTurn() && cardsArr.length >= 1){
    const finger = document.createElement('img');
    finger.className = 'my-hand-finger';
    finger.src = 'bfinger.png';
    finger.alt = '';
    finger.draggable = false;
    myHandEl.appendChild(finger);
  }
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function renderDeck(){
  const old = playerCircle.querySelector('.deck-area');
  if (old) old.remove();

  const count = (Array.isArray(state.deck) ? state.deck.length : 0);

  const deckArea = document.createElement('div');
  deckArea.className = 'deck-area';
  deckArea.id = 'deckArea';

  const stack = document.createElement('div');
  stack.className = 'deck-stack';

  const layers = Math.min(6, count);
  for (let i=0;i<layers;i++){
    const c = document.createElement('div');
    c.className = 'deck-card';
    const dx = i * 0.8;
    const dy = i * -0.8;
    c.style.transform = `translate(${dx}px, ${dy}px)`;
    c.style.opacity = String(1 - i*0.04);
    c.style.zIndex = String(10 + i);
    stack.appendChild(c);
  }

  deckArea.appendChild(stack);
  playerCircle.appendChild(deckArea);
}

function renderTurnUI(){
  renderDeck();
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = (inputName.value || '').trim() || 'Player';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribePlacedCards();
  subscribeDeck();
  subscribeTurn();
  subscribeTurnOrder();
  subscribeDrawEvents();
  subscribeVotes();
  subscribeBombEvents();

  if (state.isHost){
    const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
    const dSnap = await get(deckRef);
    if (!dSnap.exists()){
      await set(deckRef, makeInitialDeck());
    }
  }

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('„Ç≥„Éî„Éº„Åß„Åç„Åæ„Åõ„Çì„ÄÇÊâãÂãï„Åß„Ç≥„Éî„Éº„Åó„Å¶„Åè„Å†„Åï„ÅÑ', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '‰∫∫Êï∞„ÇíÈÅ∏Êäû';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = 'Â∏≠„ÇíÈÅ∏Êäû';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: (t.playerName || 'Player'),
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
    renderHands();
    renderTurnUI();
  });
}

function getCircleCenterPx(){
  const rect = playerCircle.getBoundingClientRect();
  return { cx: rect.left + rect.width/2, cy: rect.top + rect.height/2, rect };
}

function normalizePlacedList(node){
  if (!node) return [];
  if (typeof node === 'object' && node !== null && typeof node.value === 'number'){
    return [node];
  }
  if (typeof node === 'object' && node !== null){
    return Object.values(node)
      .filter(x => x && typeof x.value === 'number')
      .sort((a,b) => (a.placedAt||0) - (b.placedAt||0));
  }
  return [];
}

function escapeHTML(s){
  return String(s).replace(/[&<>"']/g, (m) => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[m]));
}

function renderPlacedIntoZone(zone, placedList){
  zone.innerHTML = '';

  const order = [];
  const groups = new Map();
  for (const pc of placedList){
    const v = pc.value;
    if (!groups.has(v)){
      groups.set(v, []);
      order.push(v);
    }
    groups.get(v).push(pc);
  }

  const STACK_OFFSET = 8;
  const CARD_H = 40;

  for (const v of order){
    const arr = groups.get(v) || [];
    const stack = document.createElement('div');
    stack.className = 'zone-stack';
    stack.style.height = `${CARD_H + Math.max(0, arr.length - 1) * STACK_OFFSET}px`;

    arr.forEach((pc, i) => {
      const zc = document.createElement('div');
      zc.className = 'zone-card';
      setCardLabelInto(zc, pc.value);

      const dy = i * STACK_OFFSET;
      zc.style.transform = `translateY(${-dy}px)`;
      zc.style.zIndex = String(10 + i);

      stack.appendChild(zc);
    });

    zone.appendChild(stack);
  }
}

/* =========================
   ‚úÖ render (ÊäïÁ•®UI„ÅØËÑ±ËêΩËÄÖ„ÅØÂá∫„Åï„Å™„ÅÑ / ÊäïÁ•®Âà§ÂÆö„ÅØÈùûËÑ±ËêΩËÄÖ„ÅÆ„Åø)
   ========================= */
function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  miniZonesByPlayerId.clear();
  if (!players.length) return;

  const n = players.length;
  const radius = 80;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.style.left = `${x}%`;
    tag.style.top = `${y}%`;
    tag.dataset.playerId = p.id;

    const isOther = (p.id !== state.userId);
    const isTheirTurn = (state.turn?.playerId && state.turn.playerId === p.id);
    if (isOther && isTheirTurn){
      tag.classList.add('other-turn');
      tag.innerHTML = `
        <div class="turn-name">${escapeHTML(p.name)}</div>
        <div class="turn-dots">„Éª„ÄÄ„Éª</div>
        <div class="turn-dash">-</div>
      `;
    } else {
      tag.textContent = p.name;
    }

    if (isBombed(p.id)){
      const b = document.createElement('div');
      b.className = 'name-bomb';
      b.textContent = 'üí£';
      tag.appendChild(b);
    }

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `„Äå${p.name}„Äç„ÇíËøΩ„ÅÑÂá∫„Åó„Å¶„ÄÅ„Åì„ÅÆÂ∏≠„Å´ÁùÄÂ∏≠„Åó„Åæ„Åô„ÅãÔºü`;
      kickDialog.classList.remove('hidden');
    };

    const handData = state.hands[p.id];
    if (p.id !== state.userId && handData && Array.isArray(handData.cards) && handData.cards.length){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const count = handData.cards.length;
      const spread = Math.min(90, 20 + count * 14);
      const base = (count > 1) ? (-spread/2) : 0;

      handData.cards.forEach((v, idx2) => {
        const card = document.createElement('div');
        card.className = 'mini-card';
        setCardLabelInto(card, v);

        const angleDeg = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
        const lift = Math.abs(angleDeg) * 0.15;
        card.style.transform = `translate(-50%,${lift}px) rotate(${angleDeg}deg)`;
        card.style.zIndex = String(10 + idx2);
        miniHand.appendChild(card);
      });

      const finger = document.createElement('img');
      finger.className = 'hand-finger';
      finger.src = 'bfinger.png';
      finger.alt = '';
      finger.draggable = false;
      miniHand.appendChild(finger);

      tag.appendChild(miniHand);
    }

    // ‚úÖ Ëá™ÂàÜ„ÅÆvote„Éú„Çø„É≥ÔºöËÑ±ËêΩ„Åó„Åü„ÇâÂá∫„Åï„Å™„ÅÑ
    if (p.id === state.userId && !isMyTurn() && !isBombed(state.userId)){
      // „Åù„ÇÇ„Åù„ÇÇÊäïÁ•®ÂØæË±°ÔºàÈùûËÑ±ËêΩËÄÖÔºâ„Åå‰ªñ„Å´„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÂá∫„Åó„Å¶„ÇÇÊÑèÂë≥„Åå„Å™„ÅÑ„ÅÆ„Åß„ÄÅÂá∫„Åï„Å™„ÅÑ
      const active = getActivePlayers();
      const activeOthersCount = active.filter(pp => pp.id !== state.userId).length;

      if (activeOthersCount > 0){
        const wrap = document.createElement('div');
        const locked = !!state.myVote;
        wrap.className = 'vote-wrap ' + (locked ? 'locked' : 'pulsing');

        const good = document.createElement('button');
        good.type = 'button';
        good.className = 'vote-btn good';
        good.setAttribute('aria-label', 'Good');
        good.addEventListener('click', async (e) => {
          e.stopPropagation();
          await chooseMyVote('good');
        });

        const bad = document.createElement('button');
        bad.type = 'button';
        bad.className = 'vote-btn bad';
        bad.setAttribute('aria-label', 'Bad');
        bad.addEventListener('click', async (e) => {
          e.stopPropagation();
          await chooseMyVote('bad');
        });

        if (state.myVote === 'good'){
          good.classList.add('selected');
          bad.classList.add('faded');
        } else if (state.myVote === 'bad'){
          bad.classList.add('selected');
          good.classList.add('faded');
        }

        wrap.appendChild(good);
        wrap.appendChild(bad);
        tag.appendChild(wrap);
      }
    }

    playerCircle.appendChild(tag);
  });

  const { cx, cy, rect } = getCircleCenterPx();

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const tagXpx = rect.left + ( (50 + radius * Math.cos(angle)) / 100 ) * rect.width;
    const tagYpx = rect.top  + ( (50 + radius * Math.sin(angle)) / 100 ) * rect.height;

    const vx = (cx - tagXpx);
    const vy = (cy - tagYpx);
    const len = Math.hypot(vx, vy) || 1;
    const ux = vx / len;
    const uy = vy / len;

    const zoneDist = 62;
    const zoneCx = tagXpx + ux * zoneDist;
    const zoneCy = tagYpx + uy * zoneDist;

    const localLeft = (zoneCx - rect.left);
    const localTop  = (zoneCy - rect.top);

    const inwardDeg = (Math.atan2(uy, ux) * 180/Math.PI) + 90;

    const zone = document.createElement('div');
    zone.className = 'mini-zone';
    zone.dataset.playerId = p.id;

    if (isBombed(p.id)) zone.classList.add('bombed');

    zone.style.left = `${localLeft}px`;
    zone.style.top  = `${localTop}px`;
    zone.style.transform = `translate(-50%,-50%) rotate(${inwardDeg}deg)`;

    const placedNode = state.placedCards?.[p.id];
    const placedList = normalizePlacedList(placedNode);

    renderPlacedIntoZone(zone, placedList);

    playerCircle.appendChild(zone);
    miniZonesByPlayerId.set(p.id, zone);
  });

  // ‚úÖ ÊäïÁ•®ÁµêÊûú„Ç¢„Ç§„Ç≥„É≥ÔºöËÑ±ËêΩËÄÖ„ÅØÈõÜË®àÂØæË±°Â§ñ„Å™„ÅÆ„ÅßË°®Á§∫„ÇÇ„Åó„Å™„ÅÑ
  const activeIds = getActivePlayerIdsSet();

  players.forEach((p, idx) => {
    if (p.id === state.userId) return;
    if (!activeIds.has(p.id)) return; // ËÑ±ËêΩËÄÖ„ÅØË°®Á§∫„Åó„Å™„ÅÑ

    const v = state.votes?.[p.id];
    const choice = v?.choice;
    if (choice !== 'good' && choice !== 'bad') return;

    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const tagXpx = rect.left + ( (50 + radius * Math.cos(angle)) / 100 ) * rect.width;
    const tagYpx = rect.top  + ( (50 + radius * Math.sin(angle)) / 100 ) * rect.height;

    const vx = (cx - tagXpx);
    const vy = (cy - tagYpx);
    const len = Math.hypot(vx, vy) || 1;
    const ux = vx / len;
    const uy = vy / len;

    const zoneDist = 62;
    const voteDist = zoneDist + 52;

    const voteCx = tagXpx + ux * voteDist;
    const voteCy = tagYpx + uy * voteDist;

    const localLeft = (voteCx - rect.left);
    const localTop  = (voteCy - rect.top);

    const indi = document.createElement('div');
    indi.className = `vote-indicator ${choice}`;
    indi.style.left = `${localLeft}px`;
    indi.style.top  = `${localTop}px`;

    playerCircle.appendChild(indi);
  });

  renderDeck();
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || 'Player' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   „Éá„ÉÉ„Ç≠/ÈÖçÂ∏É/„Çø„Éº„É≥
   ========================= */
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

async function startGameDealOneEachThenExtraToStarter(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const ordered = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { pid:t.playerId, seat:Number(seatIndex) } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seat-b.seat)
    .map(x=>x.pid);

  await set(ref(db, `rooms/${state.roomCode}/turnOrder`), ordered);

  const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
  const dSnap = await get(deckRef);

  let deck = (dSnap.exists() && Array.isArray(dSnap.val())) ? dSnap.val() : makeInitialDeck();
  deck = shuffle(deck);

  await set(ref(db, `rooms/${state.roomCode}/hands`), {});
  await remove(ref(db, `rooms/${state.roomCode}/placedCards`));
  await remove(ref(db, `rooms/${state.roomCode}/drawEvents`));
  await remove(ref(db, `rooms/${state.roomCode}/votes`));

  await remove(ref(db, `rooms/${state.roomCode}/bombed`));
  await remove(ref(db, `rooms/${state.roomCode}/bombEvents`));
  await remove(ref(db, `rooms/${state.roomCode}/freezeUntil`));

  if (!ordered.length){
    await set(deckRef, deck);
    await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: null, phase: 'draw', drawLockBy: null });
    return;
  }

  const placedWrites = [];
  for (const pid of ordered){
    if (!deck.length) break;
    const v = deck.shift();
    const key = crypto.randomUUID();
    placedWrites.push(set(ref(db, `rooms/${state.roomCode}/placedCards/${pid}/${key}`), {
      value: v,
      placedBy: 'system',
      placedAt: Date.now(),
      targetPlayerId: pid
    }));
  }
  await Promise.all(placedWrites);

  const starter = ordered[Math.floor(Math.random() * ordered.length)];

  const hands = {};
  if (deck.length){
    hands[starter] = { cards: [deck.shift()] };
  } else {
    hands[starter] = { cards: [] };
  }

  await set(ref(db, `rooms/${state.roomCode}/hands`), hands);
  await set(deckRef, deck);

  await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: starter, phase: 'place', drawLockBy: null });
}

async function autoDrawOneCard(){
  if (!state.roomCode) return;
  if (!isMyTurn()) return;
  if (state.turn.phase !== 'draw') return;
  if (state.autoDrawRunning) return;

  if (isFrozenNow()) return;
  if (isBombed(state.userId)) return;

  state.autoDrawRunning = true;

  let drawn = null;

  try {
    const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
    const lockToken = `${state.userId}:${Date.now()}`;

    const lockRes = await runTransaction(turnRef, (cur) => {
      if (!cur) return cur;
      if (cur.playerId !== state.userId) return cur;
      if (cur.phase !== 'draw') return cur;
      if (cur.drawLockBy) return cur;
      return { ...cur, drawLockBy: lockToken };
    }, { applyLocally: false });

    if (!lockRes.committed) return;

    const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
    const deckRes = await runTransaction(deckRef, (cur) => {
      if (!Array.isArray(cur) || cur.length <= 0) return cur;
      drawn = cur[0];
      return cur.slice(1);
    }, { applyLocally: false });

    if (!deckRes.committed || drawn == null){
      await set(turnRef, { playerId: state.userId, phase: 'place', drawLockBy: null });
      return;
    }

    const eventKey = crypto.randomUUID();
    await set(ref(db, `rooms/${state.roomCode}/drawEvents/${eventKey}`), {
      playerId: state.userId,
      value: drawn,
      at: Date.now()
    });

    await set(turnRef, { playerId: state.userId, phase: 'place', drawLockBy: null });
  } finally {
    state.autoDrawRunning = false;
  }
}

/* advance turn skipping bombed players */
async function advanceTurnToNext(){
  if (!state.roomCode) return;

  const order = Array.isArray(state.turnOrder) ? state.turnOrder : [];
  if (!order.length) {
    await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: null, phase: 'draw', drawLockBy: null });
    return;
  }

  const bombSnap = await get(ref(db, `rooms/${state.roomCode}/bombed`));
  const bombed = bombSnap.val() || {};

  const current = state.turn?.playerId || null;
  let idx = order.indexOf(current);
  if (idx < 0) idx = 0;

  let tries = 0;
  let nextPid = order[(idx + 1) % order.length];

  while (tries < order.length && bombed?.[nextPid]){
    idx = (idx + 1) % order.length;
    nextPid = order[(idx + 1) % order.length];
    tries++;
  }

  if (tries >= order.length && bombed?.[nextPid]){
    await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: null, phase: 'draw', drawLockBy: null });
    return;
  }

  await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: nextPid, phase: 'draw', drawLockBy: null });
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await startGameDealOneEachThenExtraToStarter();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/placedCards`)),
    remove(ref(db, `${base}/deck`)),
    remove(ref(db, `${base}/turn`)),
    remove(ref(db, `${base}/turnOrder`)),
    remove(ref(db, `${base}/drawEvents`)),
    remove(ref(db, `${base}/votes`)),

    remove(ref(db, `${base}/bombed`)),
    remove(ref(db, `${base}/bombEvents`)),
    remove(ref(db, `${base}/freezeUntil`)),
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
});

/* bomb trigger flow */
async function maybeTriggerBombForPlayer(targetPid){
  if (!state.roomCode) return false;

  const bombSnap = await get(ref(db, `rooms/${state.roomCode}/bombed/${targetPid}`));
  if (bombSnap.exists() && bombSnap.val() === true) return false;

  const placedSnap = await get(ref(db, `rooms/${state.roomCode}/placedCards/${targetPid}`));
  const placedNode = placedSnap.val() || {};
  const placedList = normalizePlacedList(placedNode);
  const points = computePointsFromPlacedList(placedList);

  if (points < POINT_THRESHOLD) return false;

  const bombedRef = ref(db, `rooms/${state.roomCode}/bombed/${targetPid}`);
  const res = await runTransaction(bombedRef, (cur) => {
    if (cur === true) return cur;
    return true;
  }, { applyLocally:false });

  if (!res.committed) return false;
  if (res.snapshot?.val() !== true) return false;

  const until = now() + BOMB_ANIM_MS + BOMB_FADE_MS;
  await set(ref(db, `rooms/${state.roomCode}/freezeUntil`), until);

  const evKey = crypto.randomUUID();
  await set(ref(db, `rooms/${state.roomCode}/bombEvents/${evKey}`), {
    playerId: targetPid,
    at: now()
  });

  await playBombForPlayer(targetPid);

  await new Promise(r => setTimeout(r, BOMB_FADE_MS));

  await remove(ref(db, `rooms/${state.roomCode}/freezeUntil`));
  await remove(ref(db, `rooms/${state.roomCode}/bombEvents/${evKey}`));

  return true;
}

/* =========================
   „Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó
   ========================= */
function startDrag(e, cardEl, value, sourceIndex){
  if (!canDragMyHandNow()) return;

  e.preventDefault();
  cardEl.setPointerCapture(e.pointerId);

  document.body.classList.add('dragging-my-card');
  clearHintZones();
  applyHintZonesDuringDrag();

  const rect = cardEl.getBoundingClientRect();
  drag.active = true;
  drag.cardEl = cardEl;
  drag.value = value;
  drag.sourceIndex = sourceIndex;

  const startX = e.clientX;
  const startY = e.clientY;
  drag.startX = startX;
  drag.startY = startY;

  const offsetX = startX - rect.left;
  const offsetY = startY - rect.top;
  drag.offsetX = offsetX;
  drag.offsetY = offsetY;

  cardEl.classList.add('dragging');
  cardEl.style.position = 'fixed';
  cardEl.style.left = `${rect.left}px`;
  cardEl.style.top  = `${rect.top}px`;
  cardEl.style.zIndex = '9999';
  cardEl.style.margin = '0';
  document.body.appendChild(cardEl);

  moveDrag(e);

  window.addEventListener('pointermove', moveDrag, { passive:false });
  window.addEventListener('pointerup', endDrag, { passive:false, once:true });
}

function moveDrag(e){
  if (!drag.active) return;
  e.preventDefault();

  const x = e.clientX - drag.offsetX;
  const y = e.clientY - drag.offsetY;
  drag.cardEl.style.left = `${x}px`;
  drag.cardEl.style.top  = `${y}px`;

  const zone = getZoneUnderPointer(e.clientX, e.clientY);

  for (const z of miniZonesByPlayerId.values()) z.classList.remove('target');
  if (zone) zone.classList.add('target');
}

function getZoneUnderPointer(px, py){
  const card = drag.cardEl;
  if (card) card.style.pointerEvents = 'none';
  const el = document.elementFromPoint(px, py);
  if (card) card.style.pointerEvents = '';

  if (!el) return null;
  const zone = el.closest?.('.mini-zone');
  if (!zone) return null;

  if (!zone.classList.contains('hint')) return null;
  return zone;
}

async function endDrag(e){
  window.removeEventListener('pointermove', moveDrag);
  if (!drag.active) return;
  e.preventDefault();

  const zone = getZoneUnderPointer(e.clientX, e.clientY);

  const droppedValue = drag.value;
  const sourceIndex = drag.sourceIndex;

  drag.cardEl.classList.remove('dragging');
  drag.cardEl.classList.remove('faceup');

  drag.cardEl.style.position = '';
  drag.cardEl.style.left = '';
  drag.cardEl.style.top = '';
  drag.cardEl.style.zIndex = '';
  drag.cardEl.style.margin = '';
  drag.cardEl.style.pointerEvents = '';
  drag.cardEl.remove();

  document.body.classList.remove('dragging-my-card');
  clearHintZones();

  const eligible = getEligibleDropPlayerIds();

  const ok =
    zone &&
    state.roomCode &&
    canDragMyHandNow() &&
    !!zone.dataset.playerId &&
    eligible.has(zone.dataset.playerId);

  if (ok){
    const myId = state.userId;
    const targetPid = zone.dataset.playerId;

    if (isBombed(targetPid)){
      renderMyHand();
      drag = { active:false, cardEl:null, value:null, sourceIndex:null, offsetX:0, offsetY:0, startX:0, startY:0 };
      return;
    }

    const handData = state.hands[myId];
    const cards = (handData && Array.isArray(handData.cards)) ? handData.cards.slice() : [];
    if (sourceIndex != null && sourceIndex >= 0 && sourceIndex < cards.length){
      cards.splice(sourceIndex, 1);
      await set(ref(db, `rooms/${state.roomCode}/hands/${myId}`), { cards });
    }

    const key = crypto.randomUUID();
    await set(ref(db, `rooms/${state.roomCode}/placedCards/${targetPid}/${key}`), {
      value: droppedValue,
      placedBy: myId,
      placedAt: Date.now(),
      targetPlayerId: targetPid
    });

    await maybeTriggerBombForPlayer(targetPid);

    await advanceTurnToNext();
  } else {
    renderMyHand();
  }

  drag = { active:false, cardEl:null, value:null, sourceIndex:null, offsetX:0, offsetY:0, startX:0, startY:0 };
}
</script>

</body>
</html>
