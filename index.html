<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn[disabled]{opacity:.45; cursor:not-allowed;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  /* ★ プレイヤー円配置用 */
  .player-circle{
    position:relative;width:260px;height:260px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;border:none;
  }
  .player-circle::before{content:'';}
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    user-select:none;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* ============================================
     ★ 他プレイヤーのミニカード（ネームタグの上に扇状）
     ============================================ */
  .player-tag .mini-hand{
    position:absolute;
    left:50%;
    bottom:100%;
    transform: translate(-50%,12px) scale(1.5);
    transform-origin: bottom center;
    width:96px;height:54px;
    pointer-events:none;
  }

  .player-tag .mini-card{
    position:absolute;left:50%;top:0;
    width:28px;height:40px;
    border-radius:8px;
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    font-size:14px;font-weight:900;
    display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
  }

  /* ★ dfinger.png（手札が1枚以上あるとき、右下に表示） */
  .player-tag .mini-hand .hand-finger{
    position:absolute;
    right:15px;
    bottom:-6px;
    width:26px;
    height:auto;
    pointer-events:none;
    filter: drop-shadow(0 6px 10px rgba(0,0,0,.18));
    z-index:100;
  }

  /* =========================
     ★ ミニカードエリア（枠＆塗りつぶしを全部消す）
     - 通常時：border/background/box-shadow/afterも無し
     - ドラッグ中：自分のカードのときだけ薄い水色でヒント
     ========================= */
  .mini-zone{
    position:absolute;
    left:50%; top:50%;
    min-width:34px;
    height:52px;

    border:none;                 /* ← remove borders */
    border-radius:10px;
    background:transparent;       /* ← remove filled bg */
    box-shadow:none;             /* ← remove shadow */
    transform-origin:center center;

    display:flex;
    flex-direction:row;
    align-items:center;
    justify-content:center;
    gap:4px;
    padding:4px;

    pointer-events:auto;
  }
  .mini-zone::after{ content:none; } /* ← remove inner dashed */

  .mini-zone.me{
    border:none;
    background:transparent;
  }

  /* ★ placement hint: only while dragging my own card */
  .mini-zone.hint{
    outline:3px solid rgba(56, 189, 248, .70);   /* light blue */
    outline-offset:2px;
    background:rgba(56, 189, 248, .12);          /* subtle fill hint */
  }

  /* zone-card is unchanged (your placed mini cards still look like cards) */
  .zone-card{
    width:28px;height:40px;border-radius:8px;border:1px solid rgba(0,0,0,.18);
    background:#fff;
    display:flex;align-items:center;justify-content:center;
    font-size:14px;font-weight:900;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    user-select:none;
    pointer-events:none;
    flex:0 0 auto;
  }

  /* ★ 手札表示（大きめ横並び） */
  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{
    display:flex;justify-content:center;gap:8px;margin-top:6px;
    min-height:110px;
    position:relative;
  }

  /* ★ カード（手札） */
  .my-card{
    width:60px;height:90px;border-radius:10px;border:1px solid #ddd;background:#fff;
    display:flex;align-items:center;justify-content:center;font-size:24px;font-weight:700;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    user-select:none;
    touch-action:none;
    transform-origin:center center;
    animation: cardPulse 1.0s ease-in-out infinite;
    cursor:grab;
  }
  .my-card:active{ cursor:grabbing; }

  @keyframes cardPulse{
    0%{ transform:scale(0.94); }
    50%{ transform:scale(1.06); }
    100%{ transform:scale(0.94); }
  }

  .my-card.dragging{
    animation:none !important;
    box-shadow:0 18px 40px rgba(0,0,0,.25);
    opacity:.98;
    cursor:grabbing;
  }

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* 詳細情報消す用 */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* =========================
     ★ 左下「？」ボタン
     ========================= */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  /* ★ ヘルプ一覧ポップ */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  /* =========================
     ★ 中央デッキ（手札の1/2程度）
     ========================= */
  .deck-area{
    position:absolute;left:50%;top:50%;
    transform:translate(-50%,-50%);
    width:36px;height:51px;
    z-index:50;
    display:flex;align-items:center;justify-content:center;
    pointer-events:none;
  }
  .deck-stack{
    position:relative;
    width:33px;height:48px;
  }
  .deck-card{
    position:absolute;left:0;top:0;
    width:33px;height:48px;border-radius:8px;
    border:1px solid rgba(0,0,0,.25);
    background:#fff;
    background-image:url('iluura.jpg');
    background-size:cover;
    background-position:center;
    box-shadow:0 10px 22px rgba(0,0,0,.20);
  }
  .deck-count{
    position:absolute;right:-8px;top:-8px;
    min-width:22px;height:22px;padding:0 6px;
    border-radius:999px;
    background:#111;color:#fff;
    border:1px solid rgba(255,255,255,.35);
    display:flex;align-items:center;justify-content:center;
    font-size:11px;font-weight:900;
    box-shadow:0 10px 22px rgba(0,0,0,.25);
    pointer-events:none;
    z-index:9999;
  }

</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle"></div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」：まず全員のミニカードエリアに<strong>1枚ずつ</strong>配る → ランダムに先手を決め、その人だけ<strong>手札を1枚</strong>受け取ります。<br>
    先手は手札を置いたら即次の人へ。以降は「自動ドロー → 置く」で進行します。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  placedCards: {},

  deck: [2,3,4,5,6,7,8],

  turn: { playerId: null, phase: 'draw' },
  turnOrder: [],

  autoDrawRunning: false,
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const turnInfo = document.getElementById('turnInfo');

const ROLE_HELP = [
  { name: "カード1", text: "ああああ" },
  { name: "カード2", text: "いいいい" },
  { name: "カード3", text: "うううう" },
  { name: "カード4", text: "うううう" },
];

function renderHelpList(){
  helpBody.innerHTML = '';
  ROLE_HELP.forEach((r, idx) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    card.textContent = `CARD ${idx+1}`;

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;

    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];

/* ★ ドラッグ状態 */
let drag = {
  active:false,
  cardEl:null,
  value:null,
  sourceIndex:null,
  offsetX:0,
  offsetY:0,
  startX:0,
  startY:0,
};
let miniZonesByPlayerId = new Map();

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
    renderTurnUI();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
    renderTurnUI();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribePlacedCards(){
  const placedRef = ref(db, `rooms/${state.roomCode}/placedCards`);
  onValue(placedRef, snap => {
    state.placedCards = snap.val() || {};
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}
function subscribeDeck(){
  const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
  onValue(deckRef, snap => {
    const d = snap.val();
    state.deck = (Array.isArray(d) ? d : []);
    renderDeck();
    renderTurnUI();
  });
}
function subscribeTurn(){
  const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
  onValue(turnRef, async snap => {
    const t = snap.val() || { playerId:null, phase:'draw' };
    state.turn = { playerId: t.playerId || null, phase: t.phase || 'draw', drawLockBy: t.drawLockBy || null };

    renderTurnUI();

    if (isMyTurn() && state.turn.phase === 'draw'){
      await autoDrawOneCard();
    }
  });
}
function subscribeTurnOrder(){
  const orderRef = ref(db, `rooms/${state.roomCode}/turnOrder`);
  onValue(orderRef, snap => {
    const arr = snap.val();
    state.turnOrder = Array.isArray(arr) ? arr : [];
    renderTurnUI();
  });
}

function renderMyHand(){
  myHandEl.innerHTML = '';
  const myId = state.userId;
  const handData = state.hands[myId];
  if (!handData || !Array.isArray(handData.cards)) return;

  handData.cards.forEach((v, idx) => {
    const card = document.createElement('div');
    card.className = 'my-card';
    card.textContent = v;

    card.addEventListener('pointerdown', (e) => {
      if (!state.roomCode) return;
      if (!isMyTurn()) return;
      if (state.turn.phase !== 'place') return;
      startDrag(e, card, v, idx);
    });

    myHandEl.appendChild(card);
  });
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function renderDeck(){
  const old = playerCircle.querySelector('.deck-area');
  if (old) old.remove();

  const count = (Array.isArray(state.deck) ? state.deck.length : 0);

  const deckArea = document.createElement('div');
  deckArea.className = 'deck-area';
  deckArea.id = 'deckArea';

  const stack = document.createElement('div');
  stack.className = 'deck-stack';

  const layers = Math.min(6, count);
  for (let i=0;i<layers;i++){
    const c = document.createElement('div');
    c.className = 'deck-card';
    const dx = i * 0.8;
    const dy = i * -0.8;
    c.style.transform = `translate(${dx}px, ${dy}px)`;
    c.style.opacity = String(1 - i*0.04);
    c.style.zIndex = String(10 + i);
    stack.appendChild(c);
  }

  const badge = document.createElement('div');
  badge.className = 'deck-count';
  badge.textContent = String(count);
  stack.appendChild(badge);

  deckArea.appendChild(stack);
  playerCircle.appendChild(deckArea);
}

function isMyTurn(){
  return state.turn?.playerId && state.turn.playerId === state.userId;
}
function getPlayerNameById(pid){
  const p = latestPlayers.find(x => x.id === pid);
  return p?.name || (pid ? 'Player' : '—');
}
function renderTurnUI(){
  if (!turnInfo){
    renderDeck();
    return;
  }
  const pid = state.turn?.playerId || null;

  if (!pid){
    turnInfo.textContent = 'Waiting…';
  } else {
    const name = getPlayerNameById(pid);
    turnInfo.textContent = `${name}`;
  }

  renderDeck();
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = (inputName.value || '').trim() || 'Player';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribePlacedCards();
  subscribeDeck();
  subscribeTurn();
  subscribeTurnOrder();

  if (state.isHost){
    const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
    const dSnap = await get(deckRef);
    if (!dSnap.exists()){
      await set(deckRef, [2,3,4,5,6,7,8]);
    }
  }

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: (t.playerName || 'Player'),
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
    renderTurnUI();
  });
}

function getCircleCenterPx(){
  const rect = playerCircle.getBoundingClientRect();
  return { cx: rect.left + rect.width/2, cy: rect.top + rect.height/2, rect };
}

function normalizePlacedList(node){
  if (!node) return [];
  if (typeof node === 'object' && node !== null && typeof node.value === 'number'){
    return [node];
  }
  if (typeof node === 'object' && node !== null){
    return Object.values(node)
      .filter(x => x && typeof x.value === 'number')
      .sort((a,b) => (a.placedAt||0) - (b.placedAt||0));
  }
  return [];
}

function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  miniZonesByPlayerId.clear();
  if (!players.length) return;

  const n = players.length;
  const radius = 80;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top = `${y}%`;

    tag.onclick = () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    const handData = state.hands[p.id];
    if (p.id !== state.userId && handData && Array.isArray(handData.cards) && handData.cards.length){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const count = handData.cards.length;
      const spread = Math.min(90, 20 + count * 14);
      const base = (count > 1) ? (-spread/2) : 0;

      handData.cards.forEach((v, idx2) => {
        const card = document.createElement('div');
        card.className = 'mini-card';
        card.textContent = String(v);

        const angleDeg = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
        const lift = Math.abs(angleDeg) * 0.15;
        card.style.transform = `translate(-50%,${lift}px) rotate(${angleDeg}deg)`;
        card.style.zIndex = String(10 + idx2);
        miniHand.appendChild(card);
      });

      const finger = document.createElement('img');
      finger.className = 'hand-finger';
      finger.src = 'bfinger.png';
      finger.alt = '';
      finger.draggable = false;
      miniHand.appendChild(finger);

      tag.appendChild(miniHand);
    }

    playerCircle.appendChild(tag);
  });

  const { cx, cy, rect } = getCircleCenterPx();

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const tagXpx = rect.left + ( (50 + radius * Math.cos(angle)) / 100 ) * rect.width;
    const tagYpx = rect.top  + ( (50 + radius * Math.sin(angle)) / 100 ) * rect.height;

    const vx = (cx - tagXpx);
    const vy = (cy - tagYpx);
    const len = Math.hypot(vx, vy) || 1;
    const ux = vx / len;
    const uy = vy / len;

    const zoneDist = 62;
    const zoneCx = tagXpx + ux * zoneDist;
    const zoneCy = tagYpx + uy * zoneDist;

    const localLeft = (zoneCx - rect.left);
    const localTop  = (zoneCy - rect.top);

    const inwardDeg = (Math.atan2(uy, ux) * 180/Math.PI) + 90;

    const zone = document.createElement('div');
    zone.className = 'mini-zone' + (p.id === state.userId ? ' me' : '');
    zone.dataset.playerId = p.id;

    zone.style.left = `${localLeft}px`;
    zone.style.top  = `${localTop}px`;
    zone.style.transform = `translate(-50%,-50%) rotate(${inwardDeg}deg)`;

    // keep pointer events for hit test, but DO NOT add hover outline anymore
    zone.addEventListener('pointerenter', () => {});
    zone.addEventListener('pointerleave', () => {});

    const placedNode = state.placedCards?.[p.id];
    const placedList = normalizePlacedList(placedNode);

    placedList.forEach((pc) => {
      const zc = document.createElement('div');
      zc.className = 'zone-card';
      zc.textContent = String(pc.value);
      zone.appendChild(zc);
    });

    playerCircle.appendChild(zone);
    miniZonesByPlayerId.set(p.id, zone);
  });

  renderDeck();
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || 'Player' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   デッキ/配布/ターン
   ========================= */
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

async function startGameDealOneEachThenExtraToStarter(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const ordered = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { pid:t.playerId, seat:Number(seatIndex) } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seat-b.seat)
    .map(x=>x.pid);

  await set(ref(db, `rooms/${state.roomCode}/turnOrder`), ordered);

  const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
  const dSnap = await get(deckRef);
  let deck = (dSnap.exists() && Array.isArray(dSnap.val())) ? dSnap.val() : [2,3,4,5,6,7,8];
  deck = shuffle(deck);

  await set(ref(db, `rooms/${state.roomCode}/hands`), {});
  await remove(ref(db, `rooms/${state.roomCode}/placedCards`));

  if (!ordered.length){
    await set(deckRef, deck);
    await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: null, phase: 'draw', drawLockBy: null });
    return;
  }

  const placedWrites = [];
  for (const pid of ordered){
    if (!deck.length) break;
    const v = deck.shift();
    const key = crypto.randomUUID();
    placedWrites.push(set(ref(db, `rooms/${state.roomCode}/placedCards/${pid}/${key}`), {
      value: v,
      placedBy: 'system',
      placedAt: Date.now(),
      targetPlayerId: pid
    }));
  }
  await Promise.all(placedWrites);

  const starter = ordered[Math.floor(Math.random() * ordered.length)];

  const hands = {};
  if (deck.length){
    hands[starter] = { cards: [deck.shift()] };
  } else {
    hands[starter] = { cards: [] };
  }

  await set(ref(db, `rooms/${state.roomCode}/hands`), hands);
  await set(deckRef, deck);

  await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: starter, phase: 'place', drawLockBy: null });
}

async function autoDrawOneCard(){
  if (!state.roomCode) return;
  if (!isMyTurn()) return;
  if (state.turn.phase !== 'draw') return;
  if (state.autoDrawRunning) return;

  state.autoDrawRunning = true;
  try {
    const turnRef = ref(db, `rooms/${state.roomCode}/turn`);
    const lockToken = `${state.userId}:${Date.now()}`;

    const lockRes = await runTransaction(turnRef, (cur) => {
      if (!cur) return cur;
      if (cur.playerId !== state.userId) return cur;
      if (cur.phase !== 'draw') return cur;
      if (cur.drawLockBy) return cur;
      return { ...cur, drawLockBy: lockToken };
    }, { applyLocally: false });

    if (!lockRes.committed) return;

    let drawn = null;
    const deckRef = ref(db, `rooms/${state.roomCode}/deck`);
    const deckRes = await runTransaction(deckRef, (cur) => {
      if (!Array.isArray(cur) || cur.length <= 0) return cur;
      drawn = cur[0];
      return cur.slice(1);
    }, { applyLocally: false });

    if (!deckRes.committed || drawn == null){
      await set(turnRef, { playerId: state.userId, phase: 'place', drawLockBy: null });
      return;
    }

    const myId = state.userId;
    const handData = state.hands[myId];
    const cards = (handData && Array.isArray(handData.cards)) ? handData.cards.slice() : [];
    cards.push(drawn);
    await set(ref(db, `rooms/${state.roomCode}/hands/${myId}`), { cards });

    await set(turnRef, { playerId: myId, phase: 'place', drawLockBy: null });

  } finally {
    state.autoDrawRunning = false;
  }
}

async function advanceTurnToNext(){
  if (!state.roomCode) return;

  const order = Array.isArray(state.turnOrder) ? state.turnOrder : [];
  if (!order.length) {
    await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: null, phase: 'draw', drawLockBy: null });
    return;
  }

  const current = state.turn?.playerId || null;
  let idx = order.indexOf(current);
  if (idx < 0) idx = 0;
  const nextPid = order[(idx + 1) % order.length];

  await set(ref(db, `rooms/${state.roomCode}/turn`), { playerId: nextPid, phase: 'draw', drawLockBy: null });
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await startGameDealOneEachThenExtraToStarter();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/placedCards`)),
    remove(ref(db, `${base}/deck`)),
    remove(ref(db, `${base}/turn`)),
    remove(ref(db, `${base}/turnOrder`)),
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
});

/* =========================
   ドラッグ＆ドロップ
   - hint is light-blue only while dragging my own card
   ========================= */
function startDrag(e, cardEl, value, sourceIndex){
  e.preventDefault();
  cardEl.setPointerCapture(e.pointerId);

  const rect = cardEl.getBoundingClientRect();
  drag.active = true;
  drag.cardEl = cardEl;
  drag.value = value;
  drag.sourceIndex = sourceIndex;

  const startX = e.clientX;
  const startY = e.clientY;
  drag.startX = startX;
  drag.startY = startY;

  const offsetX = startX - rect.left;
  const offsetY = startY - rect.top;
  drag.offsetX = offsetX;
  drag.offsetY = offsetY;

  cardEl.classList.add('dragging');
  cardEl.style.position = 'fixed';
  cardEl.style.left = `${rect.left}px`;
  cardEl.style.top  = `${rect.top}px`;
  cardEl.style.zIndex = '9999';
  cardEl.style.margin = '0';
  document.body.appendChild(cardEl);

  moveDrag(e);

  window.addEventListener('pointermove', moveDrag, { passive:false });
  window.addEventListener('pointerup', endDrag, { passive:false, once:true });
}

function moveDrag(e){
  if (!drag.active) return;
  e.preventDefault();

  const x = e.clientX - drag.offsetX;
  const y = e.clientY - drag.offsetY;
  drag.cardEl.style.left = `${x}px`;
  drag.cardEl.style.top  = `${y}px`;

  const zone = getZoneUnderPointer(e.clientX, e.clientY);

  // clear hints
  for (const z of miniZonesByPlayerId.values()) z.classList.remove('hint');

  // add hint to current zone (placement hint)
  if (zone) zone.classList.add('hint');
}

function getZoneUnderPointer(px, py){
  const card = drag.cardEl;
  if (card) card.style.pointerEvents = 'none';
  const el = document.elementFromPoint(px, py);
  if (card) card.style.pointerEvents = '';

  if (!el) return null;
  const zone = el.closest?.('.mini-zone');
  return zone || null;
}

async function endDrag(e){
  window.removeEventListener('pointermove', moveDrag);
  if (!drag.active) return;
  e.preventDefault();

  const zone = getZoneUnderPointer(e.clientX, e.clientY);

  const droppedValue = drag.value;
  const sourceIndex = drag.sourceIndex;

  drag.cardEl.classList.remove('dragging');
  drag.cardEl.style.position = '';
  drag.cardEl.style.left = '';
  drag.cardEl.style.top = '';
  drag.cardEl.style.zIndex = '';
  drag.cardEl.style.margin = '';
  drag.cardEl.style.pointerEvents = '';
  drag.cardEl.remove();

  for (const z of miniZonesByPlayerId.values()) z.classList.remove('hint');

  const ok =
    zone &&
    state.roomCode &&
    isMyTurn() &&
    state.turn.phase === 'place' &&
    !!zone.dataset.playerId;

  if (ok){
    const myId = state.userId;
    const targetPid = zone.dataset.playerId;

    const handData = state.hands[myId];
    const cards = (handData && Array.isArray(handData.cards)) ? handData.cards.slice() : [];
    if (sourceIndex != null && sourceIndex >= 0 && sourceIndex < cards.length){
      cards.splice(sourceIndex, 1);
      await set(ref(db, `rooms/${state.roomCode}/hands/${myId}`), { cards });
    }

    const key = crypto.randomUUID();
    await set(ref(db, `rooms/${state.roomCode}/placedCards/${targetPid}/${key}`), {
      value: droppedValue,
      placedBy: myId,
      placedAt: Date.now(),
      targetPlayerId: targetPid
    });

    await advanceTurnToNext();
  } else {
    renderMyHand();
  }

  drag = { active:false, cardEl:null, value:null, sourceIndex:null, offsetX:0, offsetY:0, startX:0, startY:0 };
}
</script>

</body>
</html>
